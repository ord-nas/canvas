* Things layers need to do
** DONE Contain a reference to canvas
** DONE Contain a reference to context
** Support matrix operations on context (via monkey-patching):
*** DONE Set matrix (with context update)
*** DONE Transform with matrix
*** DONE Reset transform
*** DONE Get inverse transform
** Support drawing
*** For maximum flexibility, each layer has independent:
**** DONE last_draw
**** DONE last_transform
**** DONE redraw_on_transform_change
**** DONE temp_canvas
***** DONE clear_temp_canvas()
***** DONE reset_temp_canvas()
***** DONE get_temp_canvas()
*** DONE Has strokes & stroke_buckets
*** DONE Has transforms & transform_buckets
*** DONE Draw takes a layer as argument
* Multiple layers
** DONE Add layer stack
** DONE Draw all layers on tick
** TODO Figure out whether to set redraw_on_transform_change for all layers simultaneously
** Allow layers to be:
*** DONE Added
*** DONE Removed
*** DONE Renamed
*** DONE Reordered
*** DONE Selected
** TODO Layer grouping and nesting?
*** Active library: https://github.com/ilikenwf/nestedSortable
**** Demo: http://ilikenwf.github.io/example.html
*** Deprecated library: https://github.com/mjsarfatti/nestedSortable
**** Demo: http://mjsarfatti.com/sandbox/nestedSortable/
* New tools
** TODO Eraser
** Line
*** TODO Free
*** TODO Snap to horizontal/vertical/45-degree(?)
** TODO Circle
** TODO Rectangle
** TODO Table?
** TODO Polygon?
** TODO Paintbucket
** TODO Allow brush shape to be transformed?
* Timeline view
** DONE Figure out HOW!
*** Synchronized scrollbar reference: http://jsfiddle.net/kunknown/VVaEq/2/
* Performance
** TODO Profile the drawing function (especially when it needs to redraw every frame)
** TODO Switch to using redraw_on_transform_change = false more often
*** Whenever a period of transformation begins / ends?
*** Always? Redraw in background, and use stale pictures in foreground?
**** DONE Investigate redrawing using Web Workers
***** Not available in Chrome yet! (https://bugs.chromium.org/p/chromium/issues/detail?id=563816)
**** TODO Investigate interleaving of transforming stale & redrawing
** TODO It's already kind of janky, even when not much is happening ...
** TODO Try making timelines skip updating when they are offscreen
*** https://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport/
* Refactoring
** TODO Refactor evalPeriod to take a function, apply it to each event
*** Use closures to support additional arguments
*** Transform events don't need to have an eval method, just expose the matrix
*** TODO Ensure this doesn't degrade performance
** TODO Try to fix the annoying hack in findTransformedPoint
*** Maybe give layers a getCurrentTransform method?
*** Maybe also make transformPeriod operate on matrix instead of context, so that we can perform this calculation on a matrix only instead of needing to temporarily mutate the context.
** TODO Remove all hard-coded references to height and width
* Bugs
** TODO Brush stroke width (and shape!) is affected by current transform
*** Solution:
**** First create target brush in pixel space
**** Transform it via inverse of current transform; this is the brush we are trying to create
**** Find the stroke width and shape transform that will produce this brush
**** Store it along with the stroke (need one at every point in stroke, since transform changes!)
**** At draw time, temporarily set transformation matrix = matrix * brush_transform_matrix
** TODO Automatically generated layer names may collide
*** Suppose auto-naming says next layer is "Layer 5"
*** Now rename one of the current layers to "Layer 5"
*** Create new layer
*** Now you have duplicate layers!
** TODO Need to "reflow" (aka assign new ranks) when an event is deleted
** TODO Two instantaneous events at slightly different times will overlap in the Timeline UI
** TODO When transform events are deleted/changed, need to update descendants of layer as well as just the layer itself
** TODO Need to add nesting-awareness to post_transform_draw
* Improvements
** DONE Improve drag handling
*** Make global mouseup and mousemove events, attached to body
*** A mousedown event registers global handlers
*** Global mouseup and mousemove events delegate to the current handlers
*** This allows you to start a drag inside a canvas (or other element) and continue outside it
*** Also catch when the mouse leaves the entire body, and count that as mouseup
