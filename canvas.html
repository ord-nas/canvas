<html>
    <head>
	<title>Canvas</title>
	<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
	<script
	    src="https://code.jquery.com/jquery-3.2.1.min.js"
	    integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
	    crossorigin="anonymous"></script>
	<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
	<script type="text/javascript">
	 var bucket_size = 1000 * 5;
	 var stroke_buckets = {};
	 var strokes = [];
	 var transform_buckets = {};
	 var transforms = [];
	 var playing = false;
	 var last_project_time = 0;
	 var last_real_time = 0;
	 var last_draw = null;
	 var last_transform = null;
	 var current_project_time = 0;
	 var current_seq_id = 0;

	 var svg_element = null;
	 function getIdentityMatrix() {
	     return getSVGElement().createSVGMatrix();
	 }
	 function getSVGElement() {
	     if (svg_element === null) {
		 svg_element= document.createElementNS("http://www.w3.org/2000/svg", "svg");
	     }
	     return svg_element;
	 }

	 // Based on implementation at: https://stackoverflow.com/questions/7395813/html5-canvas-get-transform-matrix
	 function addMatrixTrackingToContext(ctx) {
	     ctx._matrix = getIdentityMatrix();
	     var prior_proto = ctx.__proto__;
	     ctx.__proto__ = {
		 _set_matrix: function(m) {
		     this._matrix = m;
		     prior_proto.setTransform.call(this, m.a, m.b, m.c, m.d, m.e, m.f);
		 },
		 scale: function(x,y) {
		     this._set_matrix(this._matrix.scaleNonUniform(x, y));
		 },
		 rotate: function(theta) {
		     this._set_matrix(this._matrix.rotate(theta * 180 / Math.PI));
		 },
		 translate: function(x, y) {
		     this._set_matrix(this._matrix.translate(x, y));
		 },
		 transform: function(a, b, c, d, e, f) {
		     var m = getIdentityMatrix();
		     m.a = a; m.b = b; m.c = c; m.d = d; m.e = e; m.f = f;
		     this._set_matrix(this._matrix.multiply(m));
		 },
		 resetTransform: function() {
		     this._set_matrix(getIdentityMatrix());
		 },
		 getInverse: function() {
		     var inv = getIdentityMatrix();
		     var m = this._matrix;
		     inv.a = m.d / (m.a*m.d - m.b*m.c);
		     inv.c = -m.c / (m.a*m.d - m.b*m.c);
		     inv.e = (m.c*m.f - m.d*m.e) / (m.a*m.d - m.b*m.c);
		     inv.b = -m.b / (m.a*m.d - m.b*m.c);
		     inv.d = m.a / (m.a*m.d - m.b*m.c);
		     inv.f = (m.b*m.e - m.a*m.f) / (m.a*m.d - m.b*m.c);
		     return inv;
		 },
		 __proto__: prior_proto,
	     };
	 }
	 
	 function getMousePos(canvas, evt) {
	     var rect = canvas.getBoundingClientRect();
	     return {
		 x: evt.clientX - rect.left,
		 y: evt.clientY - rect.top,
	     };
	 }
	 
	 function findTransformedPoint(pnt, ctx) {
	     var svg_pnt = getSVGElement().createSVGPoint();
	     svg_pnt.x = pnt.x;
	     svg_pnt.y = pnt.y;
	     return svg_pnt.matrixTransform(ctx.getInverse());
	 }

	 function clear(ctx) {
	     var m = ctx._matrix;
	     ctx._set_matrix(getIdentityMatrix());
	     ctx.clearRect(0, 0, 720, 1280);
	     ctx.fillStyle = "#FAF7F8";
	     ctx.beginPath();
	     ctx.rect(0, 0, 720, 1280);
	     ctx.closePath();
	     ctx.fill();
	     ctx._set_matrix(m);
	 }
	 
	 function compare_events(a, b) {
	     if (a.time < b.time) {
		 return -1;
	     } else if (a.time > b.time) {
		 return 1;
	     } else if (a.seq_id < b.seq_id) {
		 return -1;
	     } else if (a.seq_id > b.seq_id) {
		 return 1;
	     } else {
		 return 0;
	     }
	 }

	 function extract_events(bucket) {
	     var all_events = [];
	     var i;
	     for (i = 0; i < bucket.length; i++) {
		 bucket[i].push_events_into(all_events);
	     }
	     all_events.sort(compare_events);
	     return all_events;
	 }
	 
	 function evalPeriod(start, end, buckets, args) {
	     var i, j, bucket;
	     var performed_action = false;
	     if (typeof start == "number") {
		 start = {
		     time: start,
		     seq_id: 0,
		 };
	     }
	     if (typeof end == "number") {
		 end = {
		     time: end,
		     seq_id: Infinity,
		 };
	     }
	     var start_bucket = Math.floor(start.time / bucket_size);
	     var end_bucket = Math.floor(end.time / bucket_size);
	     for (bucket = start_bucket; bucket <= end_bucket; bucket++) {
		 if (!(bucket in buckets)) {
		     continue;
		 }
		 var events = extract_events(buckets[bucket]);
		 for (i = 0; i < events.length; i++) {
		     var event = events[i];
		     if (event.time >= bucket * bucket_size &&
			 event.time < (bucket+1) * bucket_size &&
			 compare_events(event, start) >= 0 &&
			 compare_events(event, end) <= 0) {
			 event.eval(args);
			 performed_action = true;
		     }
		 }
	     }
	     return performed_action;
	 }

	 function drawPeriod(ctx, start, end) {
	     return evalPeriod(start, end, stroke_buckets, [ctx]);
	 }

	 function transformPeriod(ctx, start, end) {
	     return evalPeriod(start, end, transform_buckets, [ctx]);
	 }
	 
	 function tick() {
	     if (current_action) {
		 current_action.tick();
	     }
	     set_current_project_time();
	     draw();
	     if (playing) {
		 // TODO: should I just make this part of set_current_project_time?
		 $("#time").val(current_project_time / 1000);
	     }
	     window.requestAnimationFrame(tick);
	 }
	 
	 var always_clear = false;
	 var always_reset_transform = false;
	 var redraw_on_transform_change = true;
	 
	 function standard_draw() {
	     var layer1 = $("#layer-1").get(0);
	     var ctx1 = layer1.getContext("2d");
	     var now = {
		 time: current_project_time,
		 seq_id: current_seq_id,
	     };
	     var transform_changed = false;
	     if (always_reset_transform || compare_events(now, last_transform) < 0) {
		 console.log("RESET TRANSFORM (STANDARD)");
		 ctx1.resetTransform();
		 transformPeriod(ctx1, 0, now);
		 transform_changed = true;
	     } else  {
		 transform_changed = transformPeriod(ctx1, last_transform, now);
	     }
	     if (always_clear ||
		 compare_events(now, last_draw) < 0 ||
		 transform_changed) {
		 console.log("CLEAR (STANDARD)");
		 clear(ctx1);
		 drawPeriod(ctx1, 0, now);
	     } else {
		 drawPeriod(ctx1, last_draw, now);
	     }
	     last_draw = now;
	     last_transform = now;
	     // Do this just to leave temp_canvas in a state that
	     // post_transform_draw expects.
	     clear_temp_canvas();
	 }

	 var temp_canvas = null;
	 function clear_temp_canvas() {
	     temp_canvas = null;
	 }
	 function reset_temp_canvas() {
	     var real_canvas = $("#layer-1").get(0);
	     temp_canvas = document.createElement('canvas');
	     temp_canvas.width = real_canvas.width;
	     temp_canvas.height = real_canvas.height;
	     var ctx = temp_canvas.getContext("2d");
	     addMatrixTrackingToContext(ctx);
	     ctx.drawImage(real_canvas, 0, 0);
	     ctx._set_matrix(real_canvas.getContext("2d")._matrix);
	 }
	 function get_temp_canvas() {
	     if (temp_canvas === null) {
		 reset_temp_canvas();
	     }
	     return temp_canvas;
	 }
	 
	 function post_transform_draw() {
	     var real_layer1 = $("#layer-1").get(0);
	     var temp_layer1 = get_temp_canvas();
	     var real_ctx1 = real_layer1.getContext("2d");
	     var temp_ctx1 = temp_layer1.getContext("2d");
	     var now = {
		 time: current_project_time,
		 seq_id: current_seq_id,
	     };
	     if (compare_events(now, last_draw) < 0) {
		 console.log("RESET TRANSFORM (POST)");
		 real_ctx1.resetTransform();
		 transformPeriod(real_ctx1, 0, now);
		 console.log("CLEAR (POST)");
		 clear(real_ctx1);
		 drawPeriod(real_ctx1, 0, now);
		 reset_temp_canvas();
		 last_transform = now;
	     } else {
		 drawPeriod(temp_ctx1, last_draw, now);
		 real_ctx1.resetTransform();
		 clear(real_ctx1);
		 transformPeriod(real_ctx1, last_transform, now);
		 real_ctx1.drawImage(temp_layer1, 0, 0);
		 // Do this just to leave real_ctx's matrix in a state that
		 // standard_draw expects.
		 real_ctx1._set_matrix(temp_ctx1._matrix);
	     }
	     last_draw = now;
	 }
	 
	 function draw() {
	     if (redraw_on_transform_change) {
		 standard_draw();
	     } else {
		 post_transform_draw();
	     }
	 }
	 
	 function set_current_project_time() {
	     current_project_time = last_project_time;
	     if (playing) {
		 var now = new Date();
		 var delta = now.getTime() - last_real_time;
		 current_project_time += delta;
	     }
	 }

	 function get_current_colour() {
	     return $("#stroke_colour").val();
	 }

	 function get_current_width() {
	     return $("#stroke_width").slider("value");
	 }
	 
	 // STROKE EVENT

	 function StrokeEvent(start, end, time, seq_id, colour, width) {
	     this.start = start;
	     this.end = end;
	     this.time = time;
	     this.seq_id = seq_id;
	     this.colour = colour;
	     this.width = width;
	 }

	 StrokeEvent.prototype.eval = function(args) {
	     var ctx = args[0];
	     ctx.beginPath();
	     ctx.moveTo(this.start.x, this.start.y);
	     ctx.lineTo(this.end.x, this.end.y);
	     ctx.lineWidth = this.width;
	     ctx.strokeStyle = this.colour;
	     ctx.stroke();
	 }
	 
	 // STROKE

	 function Stroke(start, colour, width) {
	     this.start = start;
	     this.colour = colour;
	     this.width = width;
	     this.pnts = [];
	 }

	 Stroke.prototype.push_events_into = function(arr) {
	     var j;
	     for (j = 1; j < this.pnts.length; j++) {
		 arr.push(new StrokeEvent(this.pnts[j-1],
					  this.pnts[j],
					  this.start + this.pnts[j].time,
					  this.pnts[j].seq_id,
					  this.colour,
					  this.width)
		 );
	     }
	 }

	 // TRANSLATE EVENT

	 function TranslateEvent(dx, dy, time, seq_id) {
	     this.dx = dx;
	     this.dy = dy;
	     this.time = time;
	     this.seq_id = seq_id;
	 }

	 TranslateEvent.prototype.eval = function(args) {
	     var ctx = args[0];
	     ctx.translate(this.dx, this.dy);
	 }
	 
	 // TRANSLATE

	 function Translate(start) {
	     this.start = start;
	     this.deltas = [];
	 }

	 Translate.prototype.push_events_into = function(arr) {
	     var i;
	     for (i = 0; i < this.deltas.length; i++) {
		 arr.push(new TranslateEvent(this.deltas[i].dx,
					     this.deltas[i].dy,
					     this.deltas[i].time + this.start,
					     this.deltas[i].seq_id)
		 );
	     }
	 }
			 
	 // PAINT ACTION
	 
	 function PaintAction() {
	     this.active_stroke = null;
	     this.active_bucket = null;
	     this.colour = null;
	 }
	 
	 PaintAction.prototype.mouseup = function(event) {
	     if (this.active_stroke !== null) {
		 this.active_stroke = null;
		 this.active_bucket = null;
		 this.colour = null;
	     }
	 };

	 PaintAction.prototype.mousedown = function(event) {
	     if (this.active_stroke === null) {
		 var canvas = $("#layer-1").get(0);
		 var ctx = canvas.getContext("2d");
		 this.mouse_pos = getMousePos(canvas, event);
		 var pos = findTransformedPoint(this.mouse_pos, ctx);
		 var start_time = current_project_time;
		 this.active_stroke = new Stroke(start_time,
						 get_current_colour(),
						 get_current_width());
		 this.active_stroke.pnts.push({
		     x: pos.x,
		     y: pos.y,
		     time: 0,
		     seq_id: current_seq_id++,
		 });
		 strokes.push(this.active_stroke);
		 this.active_bucket = Math.floor(start_time / bucket_size);
		 if (!(this.active_bucket in stroke_buckets)) {
		     stroke_buckets[this.active_bucket] = [];
		 }
		 stroke_buckets[this.active_bucket].push(this.active_stroke);
	     }
	 };
	 
	 PaintAction.prototype.mousemove = function(event) {
	     this.mouse_pos = getMousePos($("#layer-1").get(0), event);
	     this.tick();
	 };

	 PaintAction.prototype.tick = function() {
	     if (this.active_stroke !== null) {
		 var canvas = $("#layer-1").get(0);
		 var ctx = canvas.getContext("2d");
		 var pos = findTransformedPoint(this.mouse_pos, ctx);
		 // If nothing has changed, just break
		 var last_pos = this.active_stroke.pnts[this.active_stroke.pnts.length-1];
		 if (last_pos.x == pos.x && last_pos.y == pos.y) {
		     return;
		 }
		 var project_time = current_project_time;
		 var pnt = {
		     x: pos.x,
		     y: pos.y,
		     time: project_time - this.active_stroke.start,
		     seq_id: current_seq_id++,
		 };
		 this.active_stroke.pnts.push(pnt);
		 var bucket = Math.floor(project_time / bucket_size);
		 if (bucket != this.active_bucket) {
		     if (!(bucket in stroke_buckets)) {
			 stroke_buckets[bucket] = [];
		     }
		     stroke_buckets[bucket].push(this.active_stroke);
		     this.active_bucket = bucket;
		 }
	     }
	 };

	 PaintAction.prototype.finish = PaintAction.prototype.mouseup;

	 var paint_action = new PaintAction();
	 
	 // TRANSLATE ACTION

	 function TranslateAction() {
	     this.active_transform = null;
	     this.active_bucket = null;
	 }
	 
	 TranslateAction.prototype.mouseup = function(event) {
	     if (this.active_transform !== null) {
		 this.active_transform = null;
		 this.active_bucket = null;
		 this.last_pos = null;
		 redraw_on_transform_change = true;
	     }
	 };

	 TranslateAction.prototype.mousedown = function(event) {
	     if (this.active_transform === null) {
		 this.last_pos = getMousePos($("#layer-1").get(0), event);
		 var start_time = current_project_time;
		 this.active_transform = new Translate(start_time);
		 transforms.push(this.active_transform);
		 this.active_bucket = Math.floor(start_time / bucket_size);
		 if (!(this.active_bucket in transform_buckets)) {
		     transform_buckets[this.active_bucket] = [];
		 }
		 transform_buckets[this.active_bucket].push(this.active_transform);
		 redraw_on_transform_change = false;
	     }
	 };
	 
	 TranslateAction.prototype.mousemove = function(event) {
	     if (this.active_transform !== null) {
		 var project_time = current_project_time;
		 var bucket = Math.floor(project_time / bucket_size);
		 var pos = getMousePos($("#layer-1").get(0), event);
		 var delta = {
		     dx: pos.x - this.last_pos.x,
		     dy: pos.y - this.last_pos.y,
		     time: project_time - this.active_transform.start,
		     seq_id: current_seq_id++,
		 };
		 this.active_transform.deltas.push(delta);
		 if (bucket != this.active_bucket) {
		     if (!(bucket in transform_buckets)) {
			 transform_buckets[bucket] = [];
		     }
		     transform_buckets[bucket].push(this.active_transform);
		     this.active_bucket = bucket;
		 }
		 this.last_pos = pos;
	     }
	 };

	 TranslateAction.prototype.tick = function() { /* do nothing */ }
	 TranslateAction.prototype.finish = TranslateAction.prototype.mouseup;

	 var translate_action = new TranslateAction();
	 
	 var current_action = paint_action;
	 
	 function mouseup(event) {
	     if (current_action) {
		 current_action.mouseup(event);
	     }
	 }

	 function mousedown(event) {
	     if (current_action) {
		 current_action.mousedown(event);
	     }
	 }

	 function mousemove(event) {
	     if (current_action) {
		 current_action.mousemove(event);
	     }
	 }
	 
	 function play() {
	     if (!playing) {
		 var now = new Date();
		 last_real_time = now.getTime();
		 playing = true;
	     }
	 }

	 function stop() {
	     if (playing) {
		 set_current_project_time();
		 last_project_time = current_project_time;
		 playing = false;
	     }
	 }

	 function go() {
	     if (!playing) {
		 var time = 1000*parseFloat($("#time").val());
		 if (!isNaN(time)) {
		     last_project_time = time;
		 }
		 $("#time").val(last_project_time / 1000);
	     }
	 }
	 
	 function tool_change() {
	     current_action.finish();
	     if (this.value == "paint") {
		 current_action = paint_action;
	     } else if (this.value == "translate") {
		 current_action = translate_action;
	     }
	 }
	 
	 $(document).ready(function () {
	     last_project_time = 0;
	     last_draw = {
		 time: 100,
		 seq_id: 0,
	     }; /* HACK */
	     last_transform = {
		 time: 100,
		 seq_id: 0,
	     }; /* HACK */
	     
	     var now = new Date();
	     last_real_time = now.getTime();

	     $("#layer-1").on("mousemove", mousemove);
	     $("#layer-1").on("mouseup", mouseup);
	     $("#layer-1").on("mousedown", mousedown);

	     $("#play").on("click", play);
	     $("#stop").on("click", stop);
	     $("#go").on("click", go);

	     $("input[type=radio][name=tool]").change(tool_change);

	     addMatrixTrackingToContext($("#layer-1").get(0).getContext("2d"));

	     $("#stroke_width").slider({
		 range: "min",
		 min: 1,
		 max: 25,
		 value: 1,
	     });
		 
	     window.requestAnimationFrame(tick);
	 });
	</script>
    </head>
    <body>
	<p>Hello there!</p>
	<p>Time:
	    <input type="text" id="time"/>
	    <button type="button" id="go">Go</button>
	</p>
	<p>
	    <button type="button" id="play">Play</button>
	    <button type="button" id="stop">Stop</button>
	</p>
	<p>
	    <input type="radio" name="tool" value="paint" checked="checked">Paint<br>
	    <input type="radio" name="tool" value="translate">Translate<br>
	</p>
	<p>
	    Stroke colour: <input type="color" id="stroke_colour" value="#ff0000" style="width:200px;">
	</p>
	<p>
	    Stroke width: <span id="stroke_width" style="display:inline-block;width:200px;margin-left:15px"></span>
	</p>
	<canvas id="layer-1" height="1280px" width="720px">
	    Browser doesn't support canvas! Oops!
	</canvas>
    </body>
</html>
