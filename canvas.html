<html>
    <head>
	<title>Canvas</title>
	<link rel="stylesheet" href="jquery-ui.css">
	<script src="jquery-3.2.1.min.js"></script>
	<script src="jquery-ui.js"></script>
	<style>
	 #layer_selector { list-style-type: none; margin: 0; padding: 0; width: 60%; }
	 #layer_selector li { margin: 0 3px 3px 3px; padding: 0.4em; padding-left: 1.5em; font-size: 1.4em; height: 18px; }
	 #layer_selector li span.ui-icon { position: absolute; margin-left: -1.3em; }
	 .ui-draggable, .ui-droppable { background-position: top; }
	 #rename-layer label, #rename-layer input { display:block; }
	 #rename-layer input.text { margin-bottom:0px; width:95%; padding: .4em; }
	 #rename-layer fieldset { padding:0; border:0; margin-top:10px; }
	</style>
	<script type="text/javascript">
	 var bucket_size = 1000 * 5;
	 var playing = false;
	 var last_project_time = 0;
	 var last_real_time = 0;
	 var current_project_time = 0;
	 var current_seq_id = 0;

	 var svg_element = null;
	 function getIdentityMatrix() {
	     return getSVGElement().createSVGMatrix();
	 }
	 function getSVGElement() {
	     if (svg_element === null) {
		 svg_element= document.createElementNS("http://www.w3.org/2000/svg", "svg");
	     }
	     return svg_element;
	 }

	 var matrixMaker = {
	     translation: function(x, y) {
		 var m = getIdentityMatrix();
		 m.e = x;
		 m.f = y;
		 return m;
	     },
	     scaleAbout: function(origin_x, origin_y, sx, sy) {
		 var s = getIdentityMatrix();
		 s.a = sx;
		 s.d = sy;
		 var t = this.translation(origin_x, origin_y);
		 var t_inv = this.translation(-origin_x, -origin_y);
		 return t.multiply(s).multiply(t_inv);
	     },
	     rotateAbout: function(origin_x, origin_y, radians) {
		 var r = getIdentityMatrix();
		 r.a = Math.cos(radians);
		 r.b = Math.sin(radians);
		 r.c = -r.b;
		 r.d = r.a;
		 var t = this.translation(origin_x, origin_y);
		 var t_inv = this.translation(-origin_x, -origin_y);
		 return t.multiply(r).multiply(t_inv);
	     },
	 };
	 
	 // Based on implementation at: https://stackoverflow.com/questions/7395813/html5-canvas-get-transform-matrix
	 function addMatrixTrackingToContext(ctx) {
	     ctx._matrix = getIdentityMatrix();
	     var prior_proto = ctx.__proto__;
	     ctx.__proto__ = {
		 setMatrix: function(m) {
		     this._matrix = m;
		     prior_proto.setTransform.call(this, m.a, m.b, m.c, m.d, m.e, m.f);
		 },
		 transformWithMatrix: function(m) {
		     this.setMatrix(m.multiply(this._matrix));
		 },
		 resetTransform: function() {
		     this.setMatrix(getIdentityMatrix());
		 },
		 getInverse: function() {
		     var inv = getIdentityMatrix();
		     var m = this._matrix;
		     inv.a = m.d / (m.a*m.d - m.b*m.c);
		     inv.c = -m.c / (m.a*m.d - m.b*m.c);
		     inv.e = (m.c*m.f - m.d*m.e) / (m.a*m.d - m.b*m.c);
		     inv.b = -m.b / (m.a*m.d - m.b*m.c);
		     inv.d = m.a / (m.a*m.d - m.b*m.c);
		     inv.f = (m.b*m.e - m.a*m.f) / (m.a*m.d - m.b*m.c);
		     return inv;
		 },
		 __proto__: prior_proto,
	     };
	 }
	 
	 // START LAYER DEFINITION

	 function Layer(title, id) {
	     var jCanvas = $('<canvas height="720px" width="1280px" style="position:absolute;left:0px;top:0px"></canvas>');
	     this.id = "layer-" + id;
	     jCanvas.attr('id', this.id);
	     $("#layer_set").append(jCanvas);
	     this.canvas = jCanvas.get(0);
	     this.title = title;
	     this.key = "l" + id;
	     this.ctx = this.canvas.getContext("2d");
	     addMatrixTrackingToContext(this.ctx);

	     this.last_draw = null;
	     this.last_transform = null;
	     this.redraw_on_transform_change = true;
	     this.temp_canvas = null;

	     this.stroke_buckets = {};
	     this.strokes = [];
	     this.transform_buckets = {};
	     this.transforms = [];
	 }

	 Layer.prototype.clear_temp_canvas = function() {
	     this.temp_canvas = null;
	 }
	 
	 Layer.prototype.reset_temp_canvas = function() {
	     this.temp_canvas = document.createElement('canvas');
	     this.temp_canvas.width = this.canvas.width;
	     this.temp_canvas.height = this.canvas.height;
	     var ctx = this.temp_canvas.getContext("2d");
	     addMatrixTrackingToContext(ctx);
	     ctx.drawImage(this.canvas, 0, 0);
	     ctx.setMatrix(this.ctx._matrix);
	 }
	 
	 Layer.prototype.get_temp_canvas = function() {
	     if (this.temp_canvas === null) {
		 this.reset_temp_canvas();
	     }
	     return this.temp_canvas;
	 }

	 Layer.prototype.delete = function() {
	     $("#" + this.id).remove();
	 }
	 
	 // END LAYER DEFINITION
	 
	 function addToBucket(buckets, index, item) {
	     if (!(index in buckets)) {
		 buckets[index] = [];
	     }
	     buckets[index].push(item);
	 }
	 
	 function getMousePos(evt, canvas) {
	     if (canvas === undefined) {
		 canvas = document.getElementById("tool-overlay");
	     }
	     var rect = canvas.getBoundingClientRect();
	     return {
		 x: evt.clientX - rect.left,
		 y: evt.clientY - rect.top,
	     };
	 }
	 
	 function findTransformedPoint(pnt, layer) {
	     var svg_pnt = getSVGElement().createSVGPoint();
	     svg_pnt.x = pnt.x;
	     svg_pnt.y = pnt.y;
	     // TODO: It's annoying that we have to do this ...
	     var old_m = layer.ctx._matrix;
	     var now = {
		 time: current_project_time,
		 seq_id: current_seq_id,
	     };
	     transformPeriod(layer.last_transform, now, layer);
	     svg_pnt = svg_pnt.matrixTransform(layer.ctx.getInverse());
	     layer.ctx.setMatrix(old_m);
	     // END ANNOYING
	     return svg_pnt;
	 }

	 function clear(ctx) {
	     var m = ctx._matrix;
	     ctx.resetTransform();
	     ctx.clearRect(0, 0, 1280, 720);
	     ctx.setMatrix(m);
	 }
	 
	 function compare_events(a, b) {
	     if (a.time < b.time) {
		 return -1;
	     } else if (a.time > b.time) {
		 return 1;
	     } else if (a.seq_id < b.seq_id) {
		 return -1;
	     } else if (a.seq_id > b.seq_id) {
		 return 1;
	     } else {
		 return 0;
	     }
	 }

	 function extract_events(bucket) {
	     var all_events = [];
	     var i;
	     for (i = 0; i < bucket.length; i++) {
		 bucket[i].push_events_into(all_events);
	     }
	     all_events.sort(compare_events);
	     return all_events;
	 }
	 
	 function evalPeriod(start, end, buckets, args) {
	     var i, j, bucket;
	     var performed_action = false;
	     if (typeof start == "number") {
		 start = {
		     time: start,
		     seq_id: 0,
		 };
	     }
	     if (typeof end == "number") {
		 end = {
		     time: end,
		     seq_id: Infinity,
		 };
	     }
	     var start_bucket = Math.floor(start.time / bucket_size);
	     var end_bucket = Math.floor(end.time / bucket_size);
	     for (bucket = start_bucket; bucket <= end_bucket; bucket++) {
		 if (!(bucket in buckets)) {
		     continue;
		 }
		 var events = extract_events(buckets[bucket]);
		 for (i = 0; i < events.length; i++) {
		     var event = events[i];
		     if (event.time >= bucket * bucket_size &&
			 event.time < (bucket+1) * bucket_size &&
			 compare_events(event, start) >= 0 &&
			 compare_events(event, end) <= 0) {
			 event.eval(args);
			 performed_action = true;
		     }
		 }
	     }
	     return performed_action;
	 }

	 function drawPeriod(start, end, layer, ctx) {
	     if (ctx === undefined) {
		 ctx = layer.ctx;
	     }
	     return evalPeriod(start, end, layer.stroke_buckets, [ctx]);
	 }

	 function transformPeriod(start, end, layer, ctx) {
	     if (ctx === undefined) {
		 ctx = layer.ctx;
	     }
	     return evalPeriod(start, end, layer.transform_buckets, [ctx]);
	 }
	 
	 function tick() {
	     set_current_project_time();
	     // TODO: prevent bad stuff, like deleting the last layer while a tool is in use!
	     if (current_action && current_layer) {
		 current_action.tick();
	     }
	     var i;
	     for (i = 0; i < layers.length; i++) {
		 draw(layers[i]);
	     }
	     if (playing) {
		 // TODO: should I just make this part of set_current_project_time?
		 $("#time").val(current_project_time / 1000);
	     }
	     window.requestAnimationFrame(tick);
	 }
	 
	 var always_clear = false;
	 var always_reset_transform = false;
	 
	 function standard_draw(layer) {
	     var now = {
		 time: current_project_time,
		 seq_id: current_seq_id,
	     };
	     var transform_changed = false;
	     if (always_reset_transform ||
		 layer.last_transform === null ||
		 compare_events(now, layer.last_transform) < 0) {
		 console.log("RESET TRANSFORM (STANDARD)");
		 layer.ctx.resetTransform();
		 transformPeriod(0, now, layer);
		 transform_changed = true;
	     } else  {
		 transform_changed = transformPeriod(layer.last_transform, now, layer);
	     }
	     if (always_clear ||
		 layer.last_draw === null ||
		 compare_events(now, layer.last_draw) < 0 ||
		 transform_changed) {
		 console.log("CLEAR (STANDARD)");
		 clear(layer.ctx);
		 drawPeriod(0, now, layer);
	     } else {
		 drawPeriod(layer.last_draw, now, layer);
	     }
	     layer.last_draw = now;
	     layer.last_transform = now;
	     // Do this just to leave layer.temp_canvas in a state that
	     // post_transform_draw expects.
	     layer.clear_temp_canvas();
	 }
	 
	 function post_transform_draw(layer) {
	     var temp_canvas = layer.get_temp_canvas();
	     var temp_ctx = temp_canvas.getContext("2d");
	     var now = {
		 time: current_project_time,
		 seq_id: current_seq_id,
	     };
	     if (layer.last_draw === null || compare_events(now, layer.last_draw) < 0) {
		 console.log("RESET TRANSFORM (POST)");
		 layer.ctx.resetTransform();
		 transformPeriod(0, now, layer);
		 console.log("CLEAR (POST)");
		 clear(layer.ctx);
		 drawPeriod(0, now, layer);
		 layer.reset_temp_canvas();
		 layer.last_transform = now;
	     } else {
		 drawPeriod(layer.last_draw, now, layer, temp_ctx);
		 layer.ctx.resetTransform();
		 clear(layer.ctx);
		 transformPeriod(layer.last_transform, now, layer);
		 layer.ctx.drawImage(temp_canvas, 0, 0);
		 // Do this just to leave layer.ctx's matrix in a state that
		 // standard_draw expects.
		 layer.ctx.setMatrix(temp_ctx._matrix);
	     }
	     layer.last_draw = now;
	 }
	 
	 function draw(layer) {
	     if (layer.redraw_on_transform_change) {
		 standard_draw(layer);
	     } else {
		 post_transform_draw(layer);
	     }
	 }
	 
	 function set_current_project_time() {
	     current_project_time = last_project_time;
	     if (playing) {
		 var now = new Date();
		 var delta = now.getTime() - last_real_time;
		 current_project_time += delta;
	     }
	 }

	 function get_current_colour() {
	     return $("#stroke_colour").val();
	 }

	 function get_current_width() {
	     return $("#stroke_width").slider("value");
	 }
	 
	 // STROKE EVENT

	 function StrokeEvent(start, end, time, seq_id, colour, width) {
	     this.start = start;
	     this.end = end;
	     this.time = time;
	     this.seq_id = seq_id;
	     this.colour = colour;
	     this.width = width;
	 }

	 StrokeEvent.prototype.eval = function(args) {
	     var ctx = args[0];
	     ctx.beginPath();
	     ctx.moveTo(this.start.x, this.start.y);
	     ctx.lineTo(this.end.x, this.end.y);
	     ctx.lineWidth = this.width;
	     ctx.lineCap = 'round';
	     ctx.strokeStyle = this.colour;
	     ctx.stroke();
	 }
	 
	 // STROKE

	 function Stroke(start, colour, width) {
	     this.start = start;
	     this.colour = colour;
	     this.width = width;
	     this.pnts = [];
	 }

	 Stroke.prototype.push_events_into = function(arr) {
	     var j;
	     for (j = 1; j < this.pnts.length; j++) {
		 arr.push(new StrokeEvent(this.pnts[j-1],
					  this.pnts[j],
					  this.start + this.pnts[j].time,
					  this.pnts[j].seq_id,
					  this.colour,
					  this.width)
		 );
	     }
	 }

	 
	 // TRANSFORM

	 function Transform(start) {
	     this.start = start;
	     this.deltas = [];
	 }

	 function TransformEval(args) {
	     var ctx = args[0];
	     ctx.transformWithMatrix(this.m);
	 }

	 Transform.prototype.push_events_into = function(arr) {
	     var i;
	     for (i = 0; i < this.deltas.length; i++) {
		 arr.push({
		     m: this.deltas[i].m,
		     time: this.deltas[i].time + this.start,
		     seq_id: this.deltas[i].seq_id,
		     eval: TransformEval,
		 });
	     }
	 }

	 // TRANSFORM ACTION

	 function TransformAction(matrix_fun, uses_guide_point, point_filter) {
	     // matrix_fun signature:
	     // matrix_fun(guide_point, initial_point, last_point, current_point)
	     this.active_transform = null;
	     this.active_layer = null;
	     this.active_bucket = null;
	     this.matrix_fun = matrix_fun;
	     this.point_filter = point_filter;
	     this.uses_guide_point = uses_guide_point;
	     
	     this.guide_point = null;
	     this.initial_point = null;
	     this.last_point = null;
	     this.current_point = null;
	 }
	 
	 TransformAction.prototype.mouseup = function(event) {
	     if (this.active_transform !== null) {
		 this.active_layer.redraw_on_transform_change = true;
		 this.active_transform = null;
		 this.active_layer = null;
		 this.active_bucket = null;
		 this.initial_point = null;
		 this.last_point = null;
		 this.current_point = null;
	     }
	 };

	 TransformAction.prototype.mousedown = function(event) {
	     if (this.active_transform === null) {
		 if (event.which === 1) {
		     // If we need a guide point, check that we have one
		     if (this.uses_guide_point && this.guide_point === null) {
			 return;
		     }

		     // Check if we pass the point filter
		     var pnt = getMousePos(event)
		     if (this.point_filter && !this.point_filter(this.guide_point, pnt)) {
			 return;
		     }
		     
		     this.initial_point = pnt;
		     this.current_point = this.initial_point;
		     var start_time = current_project_time;
		     this.active_transform = new Transform(start_time);
		     this.active_layer = current_layer;
		     this.active_layer.transforms.push(this.active_transform);
		     this.active_bucket = Math.floor(start_time / bucket_size);
		     addToBucket(this.active_layer.transform_buckets, this.active_bucket, this.active_transform);
		     this.active_layer.redraw_on_transform_change = false;
		 } else if (event.which === 3 && this.uses_guide_point) {
		     this.guide_point = getMousePos(event);
		     var ctx = document.getElementById("tool-overlay").getContext("2d");
		     ctx.clearRect(0, 0, 1280, 720);
		     ctx.beginPath();
		     ctx.arc(this.guide_point.x, this.guide_point.y, 5, 0, 2 * Math.PI);
		     ctx.fillStyle = "#FF0000";
		     ctx.fill();
		 }
	     }
	 };
	 
	 TransformAction.prototype.mousemove = function(event) {
	     if (this.active_transform !== null) {
		 var pnt = getMousePos(event);

		 // Check if we pass the point filter
		 if (this.point_filter && !this.point_filter(this.guide_point, pnt)) {
		     return;
		 }
		 
		 var project_time = current_project_time;
		 var bucket = Math.floor(project_time / bucket_size);
		 this.last_point = this.current_point;
		 this.current_point = pnt;
		 var delta = {
		     m: this.matrix_fun(this.guide_point,
					this.initial_point,
					this.last_point,
					this.current_point),
		     time: project_time - this.active_transform.start,
		     seq_id: current_seq_id++,
		 };
		 this.active_transform.deltas.push(delta);
		 if (bucket != this.active_bucket) {
		     addToBucket(this.active_layer.transform_buckets, bucket, this.active_transform);
		     this.active_bucket = bucket;
		 }
	     }
	 };

	 TransformAction.prototype.finish = function() {
	     this.mouseup();
	     var ctx = document.getElementById("tool-overlay").getContext("2d");
	     ctx.clearRect(0, 0, 1280, 720);
	     $("#tool-overlay").off("contextmenu");
	 }
	 
	 TransformAction.prototype.start = function() {
	     $("#tool-overlay").on("contextmenu", function(event) {
		 event.preventDefault();
	     });
	     this.guide_point = null;
	     this.initial_point = null;
	     this.last_point = null;
	     this.current_point = null;
	 }
	 
	 TransformAction.prototype.tick = function() { /* do nothing */ }

			 
	 // PAINT ACTION
	 
	 function PaintAction() {
	     this.active_stroke = null;
	     this.active_layer = null;
	     this.active_bucket = null;
	     this.colour = null;
	 }
	 
	 PaintAction.prototype.mouseup = function(event) {
	     if (this.active_stroke !== null) {
		 this.active_stroke = null;
		 this.active_layer = null;
		 this.active_bucket = null;
		 this.colour = null;
	     }
	 };

	 PaintAction.prototype.mousedown = function(event) {
	     if (this.active_stroke === null && event.which === 1) {
		 this.mouse_pos = getMousePos(event);
		 this.active_layer = current_layer;
		 var pos = findTransformedPoint(this.mouse_pos, this.active_layer);
		 var start_time = current_project_time;
		 this.active_stroke = new Stroke(start_time,
						 get_current_colour(),
						 get_current_width());
		 this.active_stroke.pnts.push({
		     x: pos.x,
		     y: pos.y,
		     time: 0,
		     seq_id: current_seq_id++,
		 });
		 this.active_layer.strokes.push(this.active_stroke);
		 this.active_bucket = Math.floor(start_time / bucket_size);
		 addToBucket(this.active_layer.stroke_buckets, this.active_bucket, this.active_stroke);
	     }
	 };
	 
	 PaintAction.prototype.mousemove = function(event) {
	     this.mouse_pos = getMousePos(event);
	     this.tick();
	 };

	 PaintAction.prototype.tick = function() {
	     if (this.active_stroke !== null) {
		 var pos = findTransformedPoint(this.mouse_pos, this.active_layer);
		 // If nothing has changed, just break
		 var last_pos = this.active_stroke.pnts[this.active_stroke.pnts.length-1];
		 if (last_pos.x == pos.x && last_pos.y == pos.y) {
		     return;
		 }
		 var project_time = current_project_time;
		 var pnt = {
		     x: pos.x,
		     y: pos.y,
		     time: project_time - this.active_stroke.start,
		     seq_id: current_seq_id++,
		 };
		 this.active_stroke.pnts.push(pnt);
		 var bucket = Math.floor(project_time / bucket_size);
		 if (bucket != this.active_bucket) {
		     addToBucket(this.active_layer.stroke_buckets, bucket, this.active_stroke);
		     this.active_bucket = bucket;
		 }
	     }
	 };

	 PaintAction.prototype.finish = PaintAction.prototype.mouseup;
	 PaintAction.prototype.start = function() { /* do nothing */ };

	 function TranslationMaker(allow_x_motion, allow_y_motion) {
	     return function(guide_point, initial_point, last_point, current_point) {
		 var dx = allow_x_motion ? current_point.x - last_point.x : 0;
		 var dy = allow_y_motion ? current_point.y - last_point.y: 0;
		 return matrixMaker.translation(dx, dy);
	     };
	 }

	 function ScaleMaker(allow_x_scale, allow_y_scale, safety_margin) {
	     if (safety_margin === undefined) {
		 safety_margin = 5;
	     }
	     var matrix_function = function(guide_point, initial_point, last_point, current_point) {
		 var sx = allow_x_scale
			? (current_point.x - guide_point.x) / (last_point.x - guide_point.x)
			: 1;
		 var sy = allow_y_scale
			? (current_point.y - guide_point.y) / (last_point.y - guide_point.y)
			: 1;
		 return matrixMaker.scaleAbout(guide_point.x, guide_point.y, sx, sy);
	     };
	     var filter_function = function(guide, pnt) {
		 if (Math.abs(guide.x - pnt.x) < safety_margin && allow_x_scale) {
		     return false;
		 } else if (Math.abs(guide.y - pnt.y) < safety_margin && allow_y_scale) {
		     return false;
		 } else {
		     return true;
		 }
	     };
	     return [matrix_function, filter_function];
	 }

	 function distance(p1, p2) {
	     var dx = p1.x - p2.x;
	     var dy = p1.y - p2.y;
	     return Math.sqrt(dx*dx + dy*dy);
	 }
	 
	 function RotationAndUniformScaleMaker(allow_rotation, allow_uniform_scale, safety_margin) {
	     if (safety_margin === undefined) {
		 safety_margin = 5;
	     }
	     var matrix_function = function(guide_point, initial_point, last_point, current_point) {
		 var current_d = distance(guide_point, current_point);
		 var last_d = distance(guide_point, last_point);
		 var s = allow_uniform_scale ? (current_d / last_d) : 1;
		 var current_r = Math.atan2(current_point.y - guide_point.y, current_point.x - guide_point.x);
		 var last_r = Math.atan2(last_point.y - guide_point.y, last_point.x - guide_point.x);
		 var r = allow_rotation ? (current_r - last_r) : 0;
		 
		 var scale_matrix = matrixMaker.scaleAbout(guide_point.x, guide_point.y, s, s);
		 var rotation_matrix = matrixMaker.rotateAbout(guide_point.x, guide_point.y, r);
		 return scale_matrix.multiply(rotation_matrix);
	     };
	     var filter_function = function(guide, pnt) {
		 return (distance(guide, pnt) >= safety_margin);
	     };
	     return [matrix_function, filter_function];
	 }

	 free_translation = TranslationMaker(true, true);
	 horizontal_translation = TranslationMaker(true, false);
	 vertical_translation = TranslationMaker(false, true);
	 [free_scale, free_scale_filter] = ScaleMaker(true, true);
	 [horizontal_scale, horizontal_scale_filter] = ScaleMaker(true, false);
	 [vertical_scale, vertical_scale_filter] = ScaleMaker(false, true);
	 [rotation, rotation_filter] = RotationAndUniformScaleMaker(true, false);
	 [uniform_scale, uniform_scale_filter] = RotationAndUniformScaleMaker(false, true);
	 [rotate_and_scale, rotate_and_scale_filter] = RotationAndUniformScaleMaker(true, true);

	 var actions = [
	     {key: "paint", title: "Paint", tool: new PaintAction()},
	     {key: "translate", title: "Translate", tool: new TransformAction(free_translation)},
	     {key: "htranslate", title: "Horizontal Translate", tool: new TransformAction(horizontal_translation)},
	     {key: "vtranslate", title: "Vertical Translate", tool: new TransformAction(vertical_translation)},
	     {key: "scale", title: "Nonuniform Scale", tool: new TransformAction(free_scale, true, free_scale_filter)},
	     {key: "hscale", title: "Horizontal Scale", tool: new TransformAction(horizontal_scale, true, horizontal_scale_filter)},
	     {key: "vscale", title: "Vertical Scale", tool: new TransformAction(vertical_scale, true, vertical_scale_filter)},
	     {key: "rotate", title: "Rotation", tool: new TransformAction(rotation, true, rotation_filter)},
	     {key: "uscale", title: "Uniform Scale", tool: new TransformAction(uniform_scale, true, uniform_scale_filter)},
	     {key: "rotate_and_scale", title: "Rotation and Scale", tool: new TransformAction(rotate_and_scale, true, rotate_and_scale_filter)},
	 ];
	 var current_action = null;

	 var layers = [];
	 var next_layer_key = 1;
	 var current_layer = null;

	 // TODO: figure out proper encapsulation
	 [make_rename_dialog, begin_rename_layer] = (function() {
	     var rename_dialog = null;
	     var current_rename_layer = null;
	     function begin_rename_layer(layer) {
		 current_rename_layer = layer;
		 $("#layer-rename-name").val(layer.title);
		 rename_dialog.dialog("open");
	     }
	     function end_rename_layer() {
		 current_rename_layer.title = $("#layer-rename-name").val();
		 rename_dialog.dialog("close");
		 update_layers();
	     }

	     function make_rename_dialog() {
		 rename_dialog = $( "#rename-layer" ).dialog({
		     autoOpen: false,
		     height: 200,
		     width: 350,
		     modal: true,
		     buttons: {
			 "Ok": end_rename_layer,
			 "Cancel": function() {
			     rename_dialog.dialog( "close" );
			 }
		     },
		 });
		 
		 rename_dialog.find( "form" ).on( "submit", function( event ) {
		     event.preventDefault();
		     return end_rename_layer();
		 });

		 return rename_dialog;
	     }

	     return [make_rename_dialog, begin_rename_layer];
	 })();
	 
	 function create_layer_handle(layer) {
	     var element = $('<li class="ui-state-default"><span class="ui-icon ui-icon-arrowthick-2-n-s"></span></li>');
	     $("<input type='radio' name='layer_handle'>")
		 .attr("value", layer.key)
		 .appendTo(element)
		 .change(update_layers);
	     $("<span class='layer-name'>")
		 .append(document.createTextNode(layer.title))
		 .appendTo(element);
	     $("<button type='button' class='layer-rename'>rename</button>")
		 .click(function() {
		     begin_rename_layer(layer);
		 })
		 .appendTo(element);
	     $("<button type='button' class='layer-delete'>delete</button>")
		 .click(function() {
		     delete_layer(layer);
		 })
		 .appendTo(element);
	     return element;
	 }
	 
	 function update_layers() {
	     var layer_handles = $("#layer_selector li input");
	     var in_order = [];
	     var i;

	     // Re-sort layers based on the order of the layer handles
	     for (i = 0; i < layer_handles.length; i++) {
		 var index = layers.findIndex(function(e) {
		     return e.key === layer_handles.eq(i).attr("value");
		 });
		 if (index !== -1) {
		     in_order.push(layers[index]);
		     layers.splice(index, 1);
		 } else {
		     layer_handles.parent().eq(i).remove();
		 }
	     }

	     // Add new layers to the handle list
	     for (i = 0; i < layers.length; i++) {
		 var element = create_layer_handle(layers[i]);
		 element.appendTo($("#layer_selector"));
	     }

	     layers = in_order.concat(layers);

	     // Handle renames
	     layer_titles = $("#layer_selector li span.layer-name");
	     for (i = 0; i < layers.length; i++) {
		 layer_titles.eq(i).text(layers[i].title);
	     }

	     // Reorder the actual canvas elements
	     for (i = 0; i < layers.length; i++) {
		 $(layers[i].canvas).css("z-index", layers.length-i);
	     }

	     $("#tool-overlay").css("z-index", layers.length+1);

	     // If no element is selected, select the first one
	     var selected = $("#layer_selector li input:checked");
	     if (selected.length === 0) {
		 $("#layer_selector li:first-child input").attr("checked", "checked");
	     }

	     // Set the current layer based on the selected
	     current_layer = null;
	     var selected = $("#layer_selector li input:checked").get(0);
	     if (selected !== undefined) {
		 for (i = 0; i < layers.length; i++) {
		     if (layers[i].key == selected.value) {
			 current_layer = layers[i];
			 break;
		     }
		 }
	     }
	 }

	 function new_layer(event) {
	     layers.push(new Layer("Layer " + next_layer_key, next_layer_key));
	     next_layer_key++;
	     update_layers();
	 }

	 function delete_layer(layer) {
	     var i;
	     for (i = 0; i < layers.length; i++) {
		 if (layers[i] == layer) {
		     layers.splice(i, 1);
		     break;
		 }
	     }
	     layer.delete();
	     update_layers();
	 }
	 
	 function mouseup(event) {
	     if (current_action && current_layer) {
		 set_current_project_time();
		 current_action.mouseup(event);
	     }
	 }

	 function mousedown(event) {
	     if (current_action && current_layer) {
		 set_current_project_time();
		 current_action.mousedown(event);
	     }
	 }

	 function mousemove(event) {
	     if (current_action && current_layer) {
		 set_current_project_time();
		 current_action.mousemove(event);
	     }
	 }
	 
	 function play() {
	     if (!playing) {
		 var now = new Date();
		 last_real_time = now.getTime();
		 playing = true;
	     }
	 }

	 function stop() {
	     if (playing) {
		 set_current_project_time();
		 last_project_time = current_project_time;
		 playing = false;
	     }
	 }

	 function go() {
	     if (!playing) {
		 var time = 1000*parseFloat($("#time").val());
		 if (!isNaN(time)) {
		     last_project_time = time;
		 }
		 $("#time").val(last_project_time / 1000);
	     }
	 }
	 
	 function tool_change() {
	     if (current_action) current_action.finish();
	     var i;
	     for (i = 0; i < actions.length; i++) {
		 if (actions[i].key == this.value) {
		     current_action = actions[i].tool;
		     break;
		 }
	     }
	     if (current_action) current_action.start();
	 }
	 
	 $(document).ready(function () {
	     last_project_time = 0;
	     last_draw = null;
	     last_transform = null;
	     
	     var now = new Date();
	     last_real_time = now.getTime();

	     $("#tool-overlay").on("mousemove", mousemove);
	     $("#tool-overlay").on("mouseup", mouseup);
	     $("#tool-overlay").on("mousedown", mousedown);

	     $("#play").on("click", play);
	     $("#stop").on("click", stop);
	     $("#go").on("click", go);
	     $("#new_layer").on("click", new_layer);

	     var i;
	     for (i = 0; i < actions.length; i++) {
		 $("<input type='radio' name='tool'>")
		     .attr("value", actions[i].key)
		     .appendTo($("#tool_set"));
		 $("#tool_set").append(document.createTextNode(actions[i].title));
	     }
	     $("#tool_set input:first-child").attr("checked", "checked");
	     $("input[type=radio][name=tool]").change(tool_change);
	     $("input[type=radio][name=tool]:checked").change();
	     
	     $("#stroke_width").slider({
		 range: "min",
		 min: 1,
		 max: 25,
		 value: 1,
	     });
		 
	     // Create the layers
	     layers = [];
	     $( "#layer_selector" ).sortable({
		 update: update_layers,
	     });
	     $( "#layer_selector" ).disableSelection();
	     update_layers();

	     // Paint the background
	     var ctx = document.getElementById("background").getContext("2d");
	     ctx.fillStyle = "#FAF7F8";
	     ctx.beginPath();
	     ctx.rect(0, 0, 1280, 720);
	     ctx.closePath();
	     ctx.fill();

	     // Set up the layer rename dialog
	     make_rename_dialog();
	     
	     window.requestAnimationFrame(tick);
	 });
	</script>
    </head>
    <body>

	<div id="rename-layer" title="Rename Layer">
	    <form>
		<fieldset>
		    <input type="text" name="name" id="layer-rename-name" value="Layer Name" class="text ui-widget-content ui-corner-all">
		    <!-- Allow form submission with keyboard without duplicating the dialog button -->
		    <input type="submit" tabindex="-1" style="position:absolute; top:-1000px">
		</fieldset>
	    </form>
	</div>
	
	<p>Time:
	    <input type="text" id="time"/>
	    <button type="button" id="go">Go</button>
	</p>
	<p>
	    <button type="button" id="play">Play</button>
	    <button type="button" id="stop">Stop</button>
	</p>
	<p id="tool_set"></p>
	<p>
	    Stroke colour: <input type="color" id="stroke_colour" value="#ff0000" style="width:200px;">
	</p>
	<p>
	    Stroke width: <span id="stroke_width" style="display:inline-block;width:200px;margin-left:15px"></span>
	</p>
	<p>Layers <button type="button" id="new_layer">New</button></p>
	<ul id="layer_selector"></ul>
	<br>
	<div id="layer_set" style="position:relative">
	    <canvas id="background" height="720px" width="1280px" style="z-index:0;position:absolute;left:0px;top:0px">
		Browser doesn't support canvas! Oops!
	    </canvas>
	    <canvas id="tool-overlay" height="720px" width="1280px" style="z-index:4;position:absolute;left:0px;top:0px">
		Browser doesn't support canvas! Oops!
	    </canvas>
	</div>
    </body>
</html>
